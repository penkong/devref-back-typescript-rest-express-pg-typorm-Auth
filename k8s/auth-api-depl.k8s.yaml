# deployment bluprint for scale with defined service(IP static) + pod  <--- configMap env var + secret

# for things that have states like database , there is component do same as deployment and it contain
# named SatefulSet
# there fore it is better to DB host outside of k8s cluster . let them replicated easier in kluster
# it is better all cluster be stateless

# each worker node get 3 process , runtime container (docker) , kubelet the process that schedule pods containers and ...
# kubelet has interface with container and Node at same time , kubelet take config and start pod it define resources also
# Nodes (physical seprated machine) communicate with services
# 3th process kube proxy is responsible to forwarding request from service to pod , prevent bad network communication
#
# Master  node, when nodes become cluster we need schedule pods accross nodes , monitoring , re-schedule restart , join new node and ...
# there are 4 process on master node .
#
# first Api server , u as deployer and developer send update/req/query to it , cluster gateway , gate keeper for authentication
# dispatcher to other procesess
#
# second Scheduler , api server hand request to scheduler . decsion on where to put pod on any node it talk with kubelet on node
#
# third Control Manager , detect died pod dying , detect change of states send request to scheduler
#
# forth etcd , key values store of cluster states , cluster brain , changes save to it .

# each computer that has all processes(4 or 3) can be Master or Worker node .

# minikube for local  master and worker are at same place
# minikube create virtual box and add porcess for run  a node to it. minikube is cluster

# kubectl for interaction . is part of Api Server
#
# kubectl create deployment nginx-depl --image=nginx
# k get deployment
# k get replicaset

# deployment manage replica set , replica set manage a pod , pod is abstraction of container
# kubectl edit deplyment nginx-depl --> get auto generated config

# debug
# kubectl logs name
# kubectl describe pod nanme
# kubectl exec -it <>pod bash
# kubectl describe service
# kubectl get pod -o wide
# kubectl get deployment name -o yaml $$$$$$$$$$$$$$$$$$$$$$$$$$$$
# k get all | grep <name>
# minikube docker-env

# with file
# kubectl apply -f filename

#  config files
#  1.metadata
#  2.specification , config , attribute of spcific about that kind
#  kinds are in apiVersion
#  3.status , auto generated by k8s , desired state =vs= actual state stored in etcd
#  yaml

# metadatas section contain labels =vs= spec part contain selector
# use for connection between deployment and pod
# first meta data in deployment use by service selector to select
#
#
#
# Namspaces : orgize resources in namespaces
#   virtual cluster inside a cluster
#   there are 4 namespaces by default
#   k get namespace
#

apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-api-depl
  labels:
    app: auth-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: auth-api
  template:
    metadata:
      labels:
        app: auth-api
    spec:
      containers:
        - name: auth-api
          image: 'penkong/starter2:latest'
          imagePullPolicy: Always
          env:
            - name: NODE_ENV
              # value: development
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: dev

            - name: DB
              # value: postgres
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: dbdriver

            - name: DBNAME
              # value: devrefauth
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: dbname

            - name: DB_DOCKER
              # value: dbpg-srv
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: dbdocker

            - name: DB_URL
              value: hfsdfdsf

            - name: PGUSER
              # value: root
              valueFrom:
                secretKeyRef:
                  name: dbpg-sec
                  key: rootPgUser

            - name: PASSWORD
              # value: secret
              valueFrom:
                secretKeyRef:
                  name: dbpg-sec
                  key: rootPgPass

            - name: PORT
              # value: '5002'
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: apiport

            - name: CORS
              # value: fdsfdsfds
              valueFrom:
                configMapKeyRef:
                  name: dbpg-confmap
                  key: cors

            - name: JWT_KEY
              # value: dsfsdfsdfsdfsdf
              valueFrom:
                secretKeyRef:
                  name: dbpg-sec
                  key: jwtkey

            - name: JWT_TTL
              # value: 365d
              valueFrom:
                secretKeyRef:
                  name: dbpg-sec
                  key: jwtttl

          resources:
            limits:
              memory: '256Mi'
              cpu: '500m'
          ports:
            - containerPort: 5002

---
apiVersion: v1
kind: Service
metadata:
  name: auth-api-srv
spec:
  type: LoadBalancer
  selector:
    app: auth-api
  ports:
    - protocol: TCP
      port: 5002
      targetPort: 5002
      nodePort: 31887
